/**************************************************************************************************
 Software License Agreement (BSD License)

 Copyright (c) 2011-2013, LAR toolkit developers - University of Aveiro - http://lars.mec.ua.pt
 All rights reserved.

 Redistribution and use in source and binary forms, with or without modification, are permitted
 provided that the following conditions are met:

  *Redistributions of source code must retain the above copyright notice, this list of
   conditions and the following disclaimer.
  *Redistributions in binary form must reproduce the above copyright notice, this list of
   conditions and the following disclaimer in the documentation and/or other materials provided
   with the distribution.
  *Neither the name of the University of Aveiro nor the names of its contributors may be used to
   endorse or promote products derived from this software without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
***************************************************************************************************/
/* Auto-generated by genmsg_cpp for file /home/prometeu/ros/inria_wheelchair/trajectory_simulator/msg/TrajectoryObservation.msg */
#ifndef TRAJECTORY_SIMULATOR_MESSAGE_TRAJECTORYOBSERVATION_H
#define TRAJECTORY_SIMULATOR_MESSAGE_TRAJECTORYOBSERVATION_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "std_msgs/Header.h"
#include "geometry_msgs/Pose2D.h"
#include "geometry_msgs/Pose2D.h"

namespace trajectory_simulator
{
template <class ContainerAllocator>
struct TrajectoryObservation_ {
  typedef TrajectoryObservation_<ContainerAllocator> Type;

  TrajectoryObservation_()
  : header()
  , object_id(0)
  , type(0)
  , pose()
  , velocity()
  {
  }

  TrajectoryObservation_(const ContainerAllocator& _alloc)
  : header(_alloc)
  , object_id(0)
  , type(0)
  , pose(_alloc)
  , velocity(_alloc)
  {
  }

  typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
   ::std_msgs::Header_<ContainerAllocator>  header;

  typedef uint32_t _object_id_type;
  uint32_t object_id;

  typedef uint8_t _type_type;
  uint8_t type;

  typedef  ::geometry_msgs::Pose2D_<ContainerAllocator>  _pose_type;
   ::geometry_msgs::Pose2D_<ContainerAllocator>  pose;

  typedef  ::geometry_msgs::Pose2D_<ContainerAllocator>  _velocity_type;
   ::geometry_msgs::Pose2D_<ContainerAllocator>  velocity;

  enum { FIRST = 1 };
  enum { LAST = 2 };

private:
  static const char* __s_getDataType_() { return "trajectory_simulator/TrajectoryObservation"; }
public:
  ROS_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }

  ROS_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }

private:
  static const char* __s_getMD5Sum_() { return "9a527b2825637f568c9382ecb8750bba"; }
public:
  ROS_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }

  ROS_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }

private:
  static const char* __s_getMessageDefinition_() { return "uint8 FIRST = 1\n\
uint8 LAST  = 2\n\
Header header\n\
uint32 object_id\n\
uint8 type\n\
geometry_msgs/Pose2D pose\n\
geometry_msgs/Pose2D velocity\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Pose2D\n\
# This expresses a position and orientation on a 2D manifold.\n\
\n\
float64 x\n\
float64 y\n\
float64 theta\n\
"; }
public:
  ROS_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }

  ROS_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
  {
    ros::serialization::OStream stream(write_ptr, 1000000000);
    ros::serialization::serialize(stream, header);
    ros::serialization::serialize(stream, object_id);
    ros::serialization::serialize(stream, type);
    ros::serialization::serialize(stream, pose);
    ros::serialization::serialize(stream, velocity);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
  {
    ros::serialization::IStream stream(read_ptr, 1000000000);
    ros::serialization::deserialize(stream, header);
    ros::serialization::deserialize(stream, object_id);
    ros::serialization::deserialize(stream, type);
    ros::serialization::deserialize(stream, pose);
    ros::serialization::deserialize(stream, velocity);
    return stream.getData();
  }

  ROS_DEPRECATED virtual uint32_t serializationLength() const
  {
    uint32_t size = 0;
    size += ros::serialization::serializationLength(header);
    size += ros::serialization::serializationLength(object_id);
    size += ros::serialization::serializationLength(type);
    size += ros::serialization::serializationLength(pose);
    size += ros::serialization::serializationLength(velocity);
    return size;
  }

  typedef boost::shared_ptr< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct TrajectoryObservation
typedef  ::trajectory_simulator::TrajectoryObservation_<std::allocator<void> > TrajectoryObservation;

typedef boost::shared_ptr< ::trajectory_simulator::TrajectoryObservation> TrajectoryObservationPtr;
typedef boost::shared_ptr< ::trajectory_simulator::TrajectoryObservation const> TrajectoryObservationConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace trajectory_simulator

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> > {
  static const char* value() 
  {
    return "9a527b2825637f568c9382ecb8750bba";
  }

  static const char* value(const  ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x9a527b2825637f56ULL;
  static const uint64_t static_value2 = 0x8c9382ecb8750bbaULL;
};

template<class ContainerAllocator>
struct DataType< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> > {
  static const char* value() 
  {
    return "trajectory_simulator/TrajectoryObservation";
  }

  static const char* value(const  ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> > {
  static const char* value() 
  {
    return "uint8 FIRST = 1\n\
uint8 LAST  = 2\n\
Header header\n\
uint32 object_id\n\
uint8 type\n\
geometry_msgs/Pose2D pose\n\
geometry_msgs/Pose2D velocity\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Pose2D\n\
# This expresses a position and orientation on a 2D manifold.\n\
\n\
float64 x\n\
float64 y\n\
float64 theta\n\
";
  }

  static const char* value(const  ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct HasHeader< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct HasHeader< const ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.header);
    stream.next(m.object_id);
    stream.next(m.type);
    stream.next(m.pose);
    stream.next(m.velocity);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct TrajectoryObservation_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::trajectory_simulator::TrajectoryObservation_<ContainerAllocator> & v) 
  {
    s << indent << "header: ";
s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "object_id: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.object_id);
    s << indent << "type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.type);
    s << indent << "pose: ";
s << std::endl;
    Printer< ::geometry_msgs::Pose2D_<ContainerAllocator> >::stream(s, indent + "  ", v.pose);
    s << indent << "velocity: ";
s << std::endl;
    Printer< ::geometry_msgs::Pose2D_<ContainerAllocator> >::stream(s, indent + "  ", v.velocity);
  }
};


} // namespace message_operations
} // namespace ros

#endif // TRAJECTORY_SIMULATOR_MESSAGE_TRAJECTORYOBSERVATION_H

